<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>uxde</title>
  <subtitle>没有一种光不可接近 请出发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https//uxde.github.io/"/>
  <updated>2017-04-07T10:05:31.000Z</updated>
  <id>https//uxde.github.io/</id>
  
  <author>
    <name>tu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《禅与Objective-C编程艺术》笔记</title>
    <link href="https//uxde.github.io/2017/04/06/%E3%80%8A%E7%A6%85%E4%B8%8EObjective-C%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0-1/"/>
    <id>https//uxde.github.io/2017/04/06/《禅与Objective-C编程艺术》笔记-1/</id>
    <published>2017-04-06T15:42:57.000Z</published>
    <updated>2017-04-07T10:05:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>条件语句应该总是被大括号包围。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (!error) &#123;</div><div class="line">    return success;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="尤达表达式"><a href="#尤达表达式" class="headerlink" title="尤达表达式"></a>尤达表达式</h3><p>不要使用尤达表达式（拿一个常量去和一个变量比较而不是拿一个变量去和常量比较），即不要用倒装的语序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if ([myValue isEqual:@42]) &#123; ...</div></pre></td></tr></table></figure>
<h3 id="nil和BOOL检查"><a href="#nil和BOOL检查" class="headerlink" title="nil和BOOL检查"></a>nil和BOOL检查</h3><p>使用感叹号来作为运算符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (someObject) &#123; ...</div><div class="line">if (![someObject boolValue]) &#123; ...</div><div class="line">if (!someObject) &#123; ...</div></pre></td></tr></table></figure></p>
<h3 id="黄金大道"><a href="#黄金大道" class="headerlink" title="黄金大道"></a>黄金大道</h3><p>不要嵌套多个<code>if</code>语句。使用多个<code>return</code>可以避免增加循环的复杂度，并提高代码的可读性。因为方法的重要部分没有嵌套在分支里面，可以很清楚地找到相关的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)someMethod &#123;</div><div class="line">    if (![someOther boolValue]) &#123;</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Do something important</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="复杂的表达式"><a href="#复杂的表达式" class="headerlink" title="复杂的表达式"></a>复杂的表达式</h3><p>当有一个复杂的<code>if</code>子句的时候，应该把他们提取出来赋给一个<code>BOOL</code>变量，让逻辑更清楚。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BOOL nameContainsSwift  = [sessionName containsString:@&quot;Swift&quot;];</div><div class="line">BOOL isCurrentYear      = [sessionDateCompontents year] == 2014;</div><div class="line">BOOL isSwiftSession     = nameContainsSwift &amp;&amp; isCurrentYear;</div><div class="line"></div><div class="line">if (isSwiftSession) &#123;</div><div class="line">    // Do something very cool</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>一个条件语句的所有变量应该是已经被求值了的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">result = a &gt; b ? x : y;</div><div class="line">result = a &gt; b ? x = c &gt; d ? c : d : y; //不推荐</div></pre></td></tr></table></figure></p>
<p>当三元运算符的第二份参数返回和条件语句中已经检查的对象一样的对象的时候，下面的表达方式更灵巧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">result = object ? : [self createObject];</div><div class="line">result = object ? object : [self createObject]; //不推荐</div></pre></td></tr></table></figure></p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>有些方法通过参数返回<code>error</code>的引用，使用这样的方法时应当检查方法的返回值，而非<code>error</code>的引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSError *error = nil;</div><div class="line">if (![self trySomethingWithError:&amp;error]) &#123;</div><div class="line">    // Handle Error</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此外，一些苹果的<code>API</code>在成功的情况下会对<code>error</code>参数（如果它非<code>NULL</code>）写入垃圾值（<code>garbage values</code>），所以如果检查<code>error</code>的值可能导致错误 （甚至崩溃）。</p>
<h3 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a><code>case</code>语句</h3><ul>
<li>括号在<code>case</code>语句里面是不必要的，但当一个<code>case</code>包含多行语句的时候，需要加上括号。</li>
<li>有时候可以使用<code>fall-through</code>在不同的<code>case</code>中执行同一段代码（移除语句中的<code>break</code>然后让下面的<code>case</code>继续执行）。</li>
<li>当在<code>switch</code>语句中使用一个可枚举的变量的时候，<code>default</code>是不必要的</li>
</ul>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>当使用<code>enum</code>的时候，建议使用新的固定的基础类型定义，因为它有更强大的类型检查和代码补全。SDK现在有一个宏来鼓励和促进使用固定类型定义 <code>NS_ENUM()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, ZOCMachineState) &#123;</div><div class="line">    ZOCMachineStateNone,</div><div class="line">    ZOCMachineStateIdle,</div><div class="line">    ZOCMachineStateRunning,</div><div class="line">    ZOCMachineStatePaused</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h3 id="通用的约定"><a href="#通用的约定" class="headerlink" title="通用的约定"></a>通用的约定</h3><p>尽可能遵守 Apple 的命名约定，尤其是和 内存管理规则 (NARC) 相关的地方。</p>
<ul>
<li>推荐使用长的、描述性的方法和变量名。</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li><p>常量应该使用以驼峰法命名，并以相关类名作为前缀。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">static const NSTimeInterval ZOCSignInViewControllerFadeOutAnimationDuration = 0.4;</div><div class="line">static const NSTimeInterval fadeOutTime = 0.4;  //不推荐</div></pre></td></tr></table></figure>
</li>
<li><p>推荐使用常量来代替字符串字面值和数字，这样能够方便复用，而且可以快速修改而不需要查找和替换。常量应该用<code>static</code>声明为静态常量，而不要用<code>#define</code>，除非它明确的作为一个宏来使用。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">static NSString * const ZOCCacheControllerDidClearCacheNotification = @&quot;ZOCCacheControllerDidClearCacheNotification&quot;;</div><div class="line">static const CGFloat ZOCImageThumbnailHeight = 50.0f;</div></pre></td></tr></table></figure>
<ul>
<li>常量应该在头文件中以下面这样的形式暴露给外部，并在实现文件中为它赋值。只有公有的常量才需要添加命名空间作为前缀。尽管实现文件中私有常量的命名可以遵循另外一种模式，你仍然可以遵循这个规则。</li>
</ul>
<p><code>extern NSString *const ZOCCacheControllerDidClearCacheNotification;</code></p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>方法名与方法类型 (<code>-</code>/<code>+</code> 符号)之间应该以空格间隔。方法段之间也应该以空格间隔（以符合 Apple 风格）。参数前应该总是有一个描述性的关键词。</li>
<li>尽可能少用 “and” 这个词。它不应该用来阐明有多个参数，比如下面的<code>initWithWidth:height:</code>这个例子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)setExampleText:(NSString *)text image:(UIImage *)image;</div><div class="line">- (void)sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag;</div><div class="line">- (id)viewWithTag:(NSInteger)tag;</div><div class="line">- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;</div></pre></td></tr></table></figure>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h3><ul>
<li>类名应该以三个大写字母作为前缀（双字母前缀为Apple的类保留）</li>
<li>当创建一个子类的时候，你应该把说明性的部分放在前缀和父类名的中间（如果你有一个<code>ZOCNetworkClient</code>类，子类的名字会是Z<code>OCTwitterNetworkClient</code>(注意<code>&quot;Twitter&quot;</code>在<code>&quot;ZOC&quot;</code>和<code>&quot;NetworkClient&quot;</code>之间); 按照这个约定， 一个<code>UIViewController</code>的子类会是<code>ZOCTimelineViewController</code>.）</li>
</ul>
<h3 id="Initalizer和dealloc"><a href="#Initalizer和dealloc" class="headerlink" title="Initalizer和dealloc"></a>Initalizer和dealloc</h3><ul>
<li>推荐的代码组织方式是将<code>dealloc</code>方法放在实现文件的最前面（直接在<code>@synthesize</code>以及<code>@dynamic</code>之后），<code>init</code>应该跟在<code>dealloc</code>方法后面。</li>
<li>如果有多个初始化方法，指定初始化方法 (designated initializer) 应该放在最前面，间接初始化方法 (secondary initializer) 跟在后面，这样更有逻辑性。</li>
</ul>
<h3 id="Designated-和-Secondary-初始化方法"><a href="#Designated-和-Secondary-初始化方法" class="headerlink" title="Designated 和 Secondary 初始化方法"></a>Designated 和 Secondary 初始化方法</h3><p>Objective-C 有指定初始化方法(designated initializer)和间接(secondary initializer)初始化方法的观念。 designated 初始化方法是提供所有的参数，secondary 初始化方法是一个或多个，并且提供一个或者更多的默认参数来调用 designated 初始化的初始化方法</p>
<ul>
<li>一个类应该有且只有一个 designated 初始化方法，其他的初始化方法应该调用这个 designated 的初始化方法（虽然这个情况有一个例外）这个分歧没有要求那个初始化函数需要被调用。<br>当定义一个新类的时候有三个不同的方式：<br>1.不需要重载任何初始化函数<br>2.重载 designated initializer<br>3.定义一个新的 designated initializer</li>
</ul>
<p>当你希望提供你自己的初始化函数的时候，你应该遵守这三个步骤来保证获得正确的行为：<br>1.定义你的 designated initializer，确保调用了直接超类的 designated initializer。<br>2.重载直接超类的 designated initializer。调用你的新的 designated initializer。<br>3.为新的 designated initializer 写文档。<br>如果没有重载超类的 designated initializer，而且调用者决定用这个方法初始化你的类(这是完全合法的)。新的 designated initializer 永远不会被调用，所以导致了不正确的初始化流程，你的类的特定初始化逻辑没有被执行。</p>
<ul>
<li>应该永远不从 designated initializer 里面调用一个 secondary initializer （如果secondary initializer 遵守约定，它会调用 designated initializer）。如果这样，调用很可能会调用一个子类重写的 init 方法并且陷入无限递归之中。(不过一个例外是一个对象是否遵守 NSCoding 协议，并且它通过方法 initWithCoder: 初始化。 我们应该看超类是否符合 NSCoding 协议来区别对待。)</li>
</ul>
<h3 id="instancetype"><a href="#instancetype" class="headerlink" title="instancetype"></a>instancetype</h3><p>一个相关的返回类型可以明确地规定用 instancetype 关键字作为返回类型，并且它可以在一些工厂方法或者构造器方法的场景下很有用。它可以提示编译器正确地检查类型，并且更加重要的是，这同时适用于它的子类。<br>根据 clang 的定义，id 可以被编译器提升到 instancetype 。在 alloc 或者 init 中，我们强烈建议对所有返回类的实例的类方法和实例方法使用 instancetype 类型。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>属性应该尽可能描述性地命名，避免缩写，并且是小写字母开头的驼峰命名。</li>
<li>应该总是使用 setter 和 getter 方法访问属性，除了 init 和 dealloc 方法。</li>
</ul>
<p>你总应该用 getter 和 setter ，因为：</p>
<ul>
<li>使用 setter 会遵守定义的内存管理语义(strong, weak, copy etc…) ，这个在 ARC 之前就是相关的内容。举个例子，copy 属性定义了每个时候你用 setter 并且传送数据的时候，它会复制数据而不用额外的操作。</li>
<li>KVO 通知(willChangeValueForKey, didChangeValueForKey) 会被自动执行。</li>
<li>更容易debug：你可以设置一个断点在属性声明上并且断点会在每次 getter / setter 方法调用的时候执行，或者你可以在自己的自定义 setter/getter 设置断点。</li>
<li>允许在一个单独的地方为设置值添加额外的逻辑。</li>
</ul>
<p>你应该倾向于用 getter：</p>
<ul>
<li>它是对未来的变化有扩展能力的（比如，属性是自动生成的）。</li>
<li>它允许子类化。</li>
<li>更简单的debug（比如，允许拿出一个断点在 getter 方法里面，并且看谁访问了特别的 getter</li>
<li>它让意图更加清晰和明确：通过访问 ivar _anIvar 你可以明确的访问 self-&gt;_anIvar.这可能导致问题。在 block 里面访问 ivar （你捕捉并且 retain 了 self，即使你没有明确的看到 self 关键词）。</li>
<li>它自动产生KVO 通知。</li>
<li>在消息发送的时候增加的开销是微不足道的。更多关于性能问题的介绍你可以看 Should I Use a Property or an Instance Variable?。</li>
</ul>
<h4 id="点符号"><a href="#点符号" class="headerlink" title="点符号"></a>点符号</h4><p>当使用 setter getter 方法的时候尽量使用点符号。应该总是用点符号来访问以及设置属性。</p>
<h3 id="属性定义"><a href="#属性定义" class="headerlink" title="属性定义"></a>属性定义</h3><p><code>@property (nonatomic, readwrite, copy) NSString *name;</code><br>(习惯上修改某个属性的修饰符时，一般从属性名从右向左搜索需要修动的修饰符。最可能从最右边开始修改这些属性的修饰符，根据经验这些修饰符被修改的可能性从高到底应为：内存管理 &gt; 读写权限 &gt;原子操作)</p>
<ul>
<li>你必须使用 nonatomic，除非特别需要的情况。在iOS中，atomic带来的锁特别影响性能。</li>
<li>属性可以存储一个代码块。为了让它存活到定义的块的结束，必须使用 copy （block 最早在栈里面创建，使用 copy让 block 拷贝到堆里面去）</li>
<li><p>为了完成一个共有的 getter 和一个私有的 setter，你应该声明公开的属性为 readonly 并且在类扩展中重新定义通用的属性为 readwrite 的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//.h文件中</div><div class="line">@interface MyClass : NSObject</div><div class="line">@property (nonatomic, readonly, strong) NSObject *object;</div><div class="line">@end</div><div class="line">//.m文件中</div><div class="line">@interface MyClass ()</div><div class="line">@property (nonatomic, readwrite, strong) NSObject *object;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation MyClass</div><div class="line">//Do Something cool</div><div class="line">@end</div></pre></td></tr></table></figure>
</li>
<li><p>描述BOOL属性的词如果是形容词，那么setter不应该带is前缀，但它对应的 getter 访问器应该带上这个前缀，如：<br><code>@property (assign, getter=isEditable) BOOL editable;</code></p>
</li>
</ul>
<h4 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h4><p>私有属性应该定义在类的实现文件的类的扩展 (匿名的 category) 中。不允许在有名字的 category(如 ZOCPrivate）中定义私有属性，除非你扩展其他类。</p>
<h3 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h3><ul>
<li>任何可以用一个可变的对象设置的（(比如 NSString,NSArray,NSURLRequest)）属性的内存管理类型必须是 copy 的。(为了确保防止在不明确的情况下修改被封装好的对象的值.)</li>
<li>应该同时避免暴露在公开的接口中可变的对象，因为这允许你的类的使用者改变类自己的内部表示并且破坏类的封装。你可以提供可以只读的属性来返回你对象的不可变的副本。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* .h */</div><div class="line">@property (nonatomic, readonly) NSArray *elements</div><div class="line"></div><div class="line">/* .m */</div><div class="line">- (NSArray *)elements &#123;</div><div class="line">return [self.mutableElements copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>当实例化一个对象需要耗费很多资源，或者配置一次就要调用很多配置相关的方法而你又不想弄乱这些方法时，我们需要重写 getter 方法以延迟实例化，而不是在 init 方法里给对象分配内存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (NSDateFormatter *)dateFormatter &#123;</div><div class="line">    if (!_dateFormatter) &#123;</div><div class="line">        _dateFormatter = [[NSDateFormatter alloc] init];</div><div class="line">        NSLocale *enUSPOSIXLocale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US_POSIX&quot;];</div><div class="line">        [_dateFormatter setLocale:enUSPOSIXLocale];</div><div class="line">        [_dateFormatter setDateFormat:@&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SSS&quot;];//毫秒是SSS，而非SSSSS</div><div class="line">    &#125;</div><div class="line">    return _dateFormatter;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即使这样做在某些情况下很不错，但是在实际这样做之前应当深思熟虑。事实上，这样的做法是可以避免的。下面是使用延迟实例化的争议。</p>
<ul>
<li>getter 方法应该避免副作用。看到 getter 方法的时候，你不会想到会因此创建一个对象或导致副作用，实际上如果调用 getter 方法而不使用其返回值编译器会报警告 “Getter 不应该仅因它产生的副作用而被调用”。</li>
<li>你在第一次访问的时候改变了初始化的消耗，产生了副作用，这会让优化性能变得困难（以及测试）</li>
<li>这个初始化可能是不确定的：比如你期望属性第一次被一个方法访问，但是你改变了类的实现，访问器在你预期之前就得到了调用，这样可以导致问题，特别是初始化逻辑可能依赖于类的其他不同状态的时候。总的来说最好明确依赖关系。</li>
<li>这个行为不是 KVO 友好的。如果 getter 改变了引用，他应该通过一个 KVO 通知来通知改变。当访问 getter 的时候收到一个改变的通知很奇怪。</li>
</ul>
<h3 id="Categories"><a href="#Categories" class="headerlink" title="Categories"></a>Categories</h3><p>应该要在我们的 category 方法前加上自己的小写前缀以及下划线，比如<code>- (id)zoc_myCategoryMethod</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSDate (ZOCTimeExtensions)</div><div class="line">- (NSString *)zoc_timeAgoShort;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<h3 id="美化代码"><a href="#美化代码" class="headerlink" title="美化代码"></a>美化代码</h3><ul>
<li>缩进使用 4 个空格。 永远不要使用 tab, 确保你在 Xcode 的设置里面是这样设置的。</li>
<li>方法的大括号和其他的大括号(if/else/switch/while 等) 总是在同一行开始，在新起一行结束。</li>
<li>方法之间应该要有一个空行来帮助代码看起来清晰且有组织。 方法内的空格应该用来分离功能，但是通常不同的功能应该用新的方法来定义。</li>
<li>优先使用 auto-synthesis。但是如果必要的话， @synthesize and @dynamic</li>
<li>在实现文件中的声明应该新起一行。</li>
<li>应该总是让冒号对齐。有一些方法签名可能超过三个冒号，用冒号对齐可以让代码更具有可读性。即使有代码块存在，也应该用冒号对齐方法。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;条件语句&quot;&gt;&lt;a href=&quot;#条件语句&quot; class=&quot;headerlink&quot; title=&quot;条件语句&quot;&gt;&lt;/a&gt;条件语句&lt;/h3&gt;&lt;p&gt;条件语句应该总是被大括号包围。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Cocoapods导入第三方库</title>
    <link href="https//uxde.github.io/2017/03/27/%E4%BD%BF%E7%94%A8Cocoapods%E5%AF%BC%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    <id>https//uxde.github.io/2017/03/27/使用Cocoapods导入第三方库/</id>
    <published>2017-03-27T11:54:53.000Z</published>
    <updated>2017-04-05T11:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进入到工程的根目录中，创建空白的Podfile文件"><a href="#进入到工程的根目录中，创建空白的Podfile文件" class="headerlink" title="进入到工程的根目录中，创建空白的Podfile文件"></a>进入到工程的根目录中，创建空白的Podfile文件</h3><ol>
<li>cd project</li>
<li>touch Podfile</li>
<li>打开Podfile，在第一行写下platform :ios, ‘9.0’，指定平台以及所支持的版本。</li>
<li>在单独一行用pod ‘libraryName’，指定需要导入的依赖。</li>
<li>pod install</li>
</ol>
<blockquote>
<p>pod init 可以直接创建具有模板的Podfile文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">target &apos;test3&apos; do</div><div class="line">    # Comment the next line if you&apos;re not using Swift and don&apos;t want to use dynamic frameworks</div><div class="line">    use_frameworks!</div><div class="line"></div><div class="line">    # Pods for test3</div><div class="line"></div><div class="line">    pod &apos;SnapKit&apos; , &apos;~&gt; 3.0.0&apos;</div><div class="line">    pod &apos;Alamofire&apos; , &apos;~&gt; 4.0&apos;</div><div class="line">    pod &apos;SwiftyJSON&apos; , &apos;~&gt; 3.0&apos;</div><div class="line"></div><div class="line"></div><div class="line">    target &apos;test3Tests&apos; do</div><div class="line">        inherit! :search_paths</div><div class="line">        # Pods for testing</div><div class="line">    end</div><div class="line"></div><div class="line">    target &apos;test3UITests&apos; do</div><div class="line">        inherit! :search_paths</div><div class="line">        # Pods for testing</div><div class="line">    end</div><div class="line"></div><div class="line">end</div></pre></td></tr></table></figure>
<h3 id="pod-install-和-pod-update"><a href="#pod-install-和-pod-update" class="headerlink" title="pod install 和 pod update"></a>pod install 和 pod update</h3><h5 id="pod-install"><a href="#pod-install" class="headerlink" title="pod install"></a>pod install</h5><ul>
<li>导入新库，或者移除原有的库。还是先编辑 Podfile 文件，再执行 install 命令。每次pod install被执行，都会下载和安装新的pods。被安装的pods的版本都会写入到Podfile.lock文件中。这个文件会一直跟踪已安装的每一个pods的版本号，并且锁定这些版本号。</li>
<li>当你执行pod install，它只会解决那些没有在Podfile.lock文件中列出来的pods的依赖。<br>  -对于Podfile.lock中列出的pods，只会下载Podfile.lock明确记录的版本，而不会去查看是否有新的版本。<br>  -对于没有在Podfile.lock中列出的pods，会去匹配Podfile文件中描述的版本，如pod ‘AFNetworking’, ‘~&gt; 3.0’。</li>
</ul>
<h5 id="pod-updata"><a href="#pod-updata" class="headerlink" title="pod updata"></a>pod updata</h5><ul>
<li>pod outdated 可以查看有哪些pods有新的版本</li>
<li>执行 pod update PODNAME CocoaPods会尝试发现PODNAME的可更新的版本，而不会去关注Podfile.lock中的版本。它会把依赖更新到最新的版本。</li>
<li>pod update CocoaPods就会将所有列在Podfile中的依赖更新到最新版本。</li>
</ul>
<h3 id="Podfile-lock"><a href="#Podfile-lock" class="headerlink" title="Podfile.lock"></a>Podfile.lock</h3><ul>
<li>每一次修改Podfile.lock后，你必须要commit &amp; push它到Repo。 可以把pod install之后生成的Pods文件夹放入到Repo中，来管理依赖版本。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;进入到工程的根目录中，创建空白的Podfile文件&quot;&gt;&lt;a href=&quot;#进入到工程的根目录中，创建空白的Podfile文件&quot; class=&quot;headerlink&quot; title=&quot;进入到工程的根目录中，创建空白的Podfile文件&quot;&gt;&lt;/a&gt;进入到工程的根目录中，
    
    </summary>
    
    
      <category term="ios" scheme="https//uxde.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>hello world</title>
    <link href="https//uxde.github.io/2017/03/25/hello%20world/"/>
    <id>https//uxde.github.io/2017/03/25/hello world/</id>
    <published>2017-03-25T08:09:52.000Z</published>
    <updated>2017-03-25T08:10:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>hello world</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hello world&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
